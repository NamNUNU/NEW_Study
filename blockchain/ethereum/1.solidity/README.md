# 솔리디티(Solidity)

해당 README는 [프로그래머스](https://programmers.co.kr/learn/courses/36)의 무료 강의 중, 
이더리움 솔리디티 실습 튜토리얼 설명에 해당하는 부분을 옮겼음을 밝힙니다.

## 솔리디티(Solidity) 언어란?
솔리디티는 이더리움 블록체인 플랫폼에서 스마트 계약(Smart Contract)를 정의하는 언어이다.
솔리디티 문법은 자바스크립트 문법과 유사하다. 다만, 정적 타입 언어1라, 자료형을 명시해주어야한다.

## DApp이란?
스마트 계약을 구현한 블록체인 기반의 탈중앙화2 애플리케이션이다.

솔리디티는 다른 언어와 마찬가지로, 다양한 자료형을 지원한다.
※ 단, 부동소수점 자료형(float)은 지원하지 않는다.

## 솔리디티의 자료형

솔리디티의 자료형은 다음과 같다.

### 주요 자료형

- uint : 부호가 없는 정수형
- int : 정수형
- bool : 논리 자료형
- string : UTF-8 인코딩 문자열
- bytes : 바이트
- address : 이더리움 주소 값 (0xaDc7192A0…)

### 레퍼런스 자료형

- 배열 : 자료형이 같은 데이터를 묶은 자료 구조이다.
- 구조체1 : 다양한 자료형의 데이터를 묶은 자료 구조이다.


## 연산자와 제어문

솔리디티에서는 연산자와 제어문을 사용할 수 있다.

### 솔리디티의 연산자(Operator)

- 논리 연산자: !, &&, ||
- 비교 연산자 : <=, <, ==, !=, >=, >
- 비트 연산자: &, |, ^, <<, >> (시프트 연산자)
- 단항(unary) 산술 연산자: +, -
- 이항(binary) 산술 연산자: +, -, *, / (몫), % (나머지), ** (거듭 제곱)

### 제어문(Control Structures)

- 조건문: if, else, ? : (삼항 연산자)
- 반복문: while, do, for
- 반복문 분기: break, continue
- 반환문: return
※ 여타 언어의 switch/case나 goto 문은 지원하지 않는다.
※ 솔리디티는 자동 형 변환(type conversion)을 하지 않는다. 예를 들어 if (true) { ... }는 허용하지만 if (1) { ... }는 허용하지 않는다.

## 이더리움 송금하기

사람 뿐만 아니라, 스마트 계약도 내부적으로 이더리움 계정1를 가집니다. 스마트 계약은 계약 계정를 통해 이더를 거래합니다.
예를 들어, 계약을 통해 A가 B에게 10 이더를 보내는 계약을 호출할 때, 이더는 사실 다음과 같이 이동합니다.

- A가 A 계정에서 계약 계정으로 10 이더를 송금
- 계약이 계약 계정에서 B 계정으로 10이더를 송금

### Payable 키워드

payable 키워드는 계약 계정에 외부에서 이더를 송금 받을 수 있도록 한다. 즉, 계약이 A에게 송금을 받으려면 A가 호출하는 함수에 payable 키워드가 있어야한다.
payable 함수는 다음과 같이 사용한다.

```solidity
function 함수이름() payable public {
    //함수 내용
}
```

### transfer 함수

Transfer 함수
**transfer 함수**를 사용하면 계약이 다른 이에게 이더를 전송합니다. **transfer 함수**는 다음과 같이 사용한다.

<받는 사람의 주소>.transfer(<송금할 금액>);
예를 들어, 다음은 계약이 **seller**에게 10 만큼의 이더를 전송하는 함수, **buy**를 구현한 예이다.

```solidity
function buy() public {
    seller.transfer(10)
}
```

또는 다음과 같다

```
pragma solidity ^0.4.18;

contract Solution {
    address friend;

    function transfer() payable public {
        friend.transfer(msg.value);
    }

    function set(address _friend) public {
        friend = _friend;
    }
}
```

## 메세지 프로퍼티

이전 강의에서는 payable 키워드를 통해 A 주소에서 계약 주소로 10 이더를 송금 하는 방법을 알아보았다.
이번 강의에서는 계약이 이더를 보낸 사람을 파악하는 법을 알아보자.

메세지 프로퍼티(Message Properties)
계약은 msg 프로퍼티를 사용해 계약을 호출한 사람이 보낸 메세지를 확인한다. msg 프로퍼티는 다음과 같은 정보를 담는다.

| 정보   | 타입    | 설명                                    |
|--------|---------|-----------------------------------------|
| data   | byte    | 호출 데이터                             |
| sender | address | 계약을 호출한 이더리움 주소             |
| value  | uint    | 계약 주소로 보낸 이더량                 |
| gas    | uint    | gas limit에서 가스를 호출하고 남은 가스 |

## 계약 수수료, gas

### 스마트 계약은 어떻게 실행될까?

작성된 스마트 계약은 EVM1 타깃으로 컴파일된 후, 이더리움 네트워크에 배포된다. 
이렇게 배포된 스마트 계약 코드는 Gas라는 수수료를 내야 사용할 수 있다.

### 수수료는 왜 나가나요?

스마트 계약은 실제로 블록체인을 관리하는 노드들에 의해 실행된다. 이때 노드는 데이터를 검증하고, 기록하는 등 다양한 일을 해준다.
따라서 이 일을 해주는 대가로 Gas라고 부르는 수수료를 내야 한다.
스마트 계약에 명령어가 많은 수록 Gas를 더 많이 내야 한다.

## 트랜잭션

우리는 지금 스마트 계약을 통해 A에서 B로 이더를 보내는 방법을 배웠다.
이번 시간에는 계약이 성사되고 남은 영수증을 확인하는 방법을 알아보자.

### 트랜잭션 확인하기

스마트 계약을 실행하면 이더리움 블록체인에 기록이 남는다. 이 기록은 트랜잭션(Transaction) 이라는 특수한 형태로 저장되는데요. 트랜잭션은 계약을 수행하는데 든 수수료(가스) 등 다양한 정보를 담고 있다.

### 트랜잭션이 담은 정보

transactionHash : 트랜잭션의 해시값
transactionIndex : 트랜잭션의 인덱스 값
blockHash : 이 트랜잭션이 추가된 블록의 해시값
blockNumber : 이 트랜잭션이 추가된 블록의 번호
gasUsed : 이 트랜잭션 호출에 소비한 가스양
cumulativeGasUsed : 누적으로 사용된 가스량
contractAddress : 계약의 주소
logs : event로 로깅된 정보


## 접근 제어자
솔리디티에선 접근 제어자(Visibility Modifiers)를 통해 상태 변수와 함수에 접근 범위를 제한 할 수 있다. 솔리디티에서 사용할 수 있는 접근 제어자는 다음과 같다.

- public 접근 제어자
- internal 접근 제어자
- private 접근 제어자
- external 접근 제어자

### 사용 예시
// 상태 변수에서의 접근 제어자 사용
string private secret = "i like u";

// 함수에서의 접근 제어자 사용
function f() public returns (uint) {
    // 어쩌고저쩌고
}

### 접근 제어자 별 차이점
- public 접근 제어자
이 접근 제어자가 선언된 함수는 외부에서 호출할 수 있다.
또한, 이 접근 제어자로 상태 변수를 선언하면 자동으로 Getter 함수를 생성해 준다.
※ 접근 제어자를 명시하지 않은 함수는 public으로 선언된다.

- internal 접근 제어자
이 상태 변수/함수를 선언한 계약과 그 계약을 상속1 받은 계약에서만 호출할 수 있다.
※ 접근 제어자를 명시하지 않은 상태 변수는 internal로 선언된다.

- private 접근 제어자
이 접근 제어자가 선언된 상태 변수/함수는 해당 계약에서만 호출할 수 있다. 
상속 받은 계약도 private으로 선언된 상태 변수/함수를 호출할 수 없다.

- external 접근 제어자
인터페이스2 의 함수를 의미한다. 
이 상태 변수/함수를 선언한 계약 내부에서는 이 상태 변수/함수를 호출할 수 없다.

## View 함수

스마트 계약은 실행하는데 수수료가 든다. 기왕이면 수수료는 적게 내는게 좋다. 데이터를 읽기만 하는 단순 작업은 가스를 소모하지 않게 설정 해주자.

View 함수
수수료를 아끼려면 view 키워드를 붙여 함수를 선언해보세요. View 함수의 특징은 다음과 같다.

상태를 변경하지 않는다: 블록체인 네트워크 상의 데이터를 읽기만 할 수 있고 데이터를 수정할 수 없다.
가스를 소모하지 않는다: 호출할 때 Gas를 사용하지 않는다.
다음은 View 함수 사용 예시이다.

```solidity
contract Variables {
    uint year = 2018;

    function get() public view returns (uint) {
        return year;
    }
}
```

## Pure 함수

pure 키워드를 붙인 함수는 가스를 소모하지 않는다. Pure 함수의 특징은 다음과 같다.

블록체인 네트워크에 기록된 데이터에 아예 접근하지 않는다.
파라미터로 주어지지 않은 상태 변수는 읽거나 쓸 수 없다.
※ 함수형 언어의 순수 함수(pure function)와 의미가 같다.

다음은 Pure 함수 사용 예시이다.

```solidity
function multiply(uint a) public pure returns (uint) {
    return a*3;
}
```

Pure 함수와 View 함수는 다음과 같은 차이가 있다.

|            구분            | 일반 함수 | View 함수 | Pure 함수 |
|:--------------------------:|:---------:|:---------:|:---------:|
| 네트워크에 기록된 상태읽기 |     O     |     O     |     X     |
| 네트워크에 기록된 상태쓰기 |     O     |     X     |     X     |
| 호출시 가스 소모           |     O     |     X     |     X     |

## 이벤트(Event)

우리는 앞선 예제에서 다른 이에게 이더를 송금했다.
이번 강의에서는 송금시 이더를 보내는 사람과 받는 사람의 정보 등을 기록하는 법을 배워보자.

계약이 수행된 정보는 트랜잭션으로 남는다. (이전 강의 참고)
트랜잭션에 기록하고 싶은 사항이 있다면 이벤트를 사용하자. 

이벤트는

1. 트랜젝션에 로깅을 남긴다.
2. event 키워드로 선언한다.
3. 로깅하고 싶은 데이터 타입과 이름을 명시한다.

다음은 물건이 구입될때마다 구매자의 이더리움 주소와 결제 금액을 기록하는 이벤트 선언/호출 예시이다.

- 이벤트 선언 예1
- 
```solidity
event BuySomethings(
    address indexed _buyer,
    uint256 _value
);
```

- 이벤트 호출 예: BuySomethings 이벤트를 호출하는 buy() 함수

```solidity
function buy() payable public {
    seller.transfer(msg.value);

    // 이벤트 호출
    BuySomethings(msg.sender, msg.value);
}
```