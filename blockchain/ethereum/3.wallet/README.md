# 지갑 서비스 구축

## 지갑

지갑은 계정들의 모음이고, 계정은 주소와 이에 연관된 개인 키의 조합이다. 지갑의 종류는 다음과 같다

- 온라인 지갑 
  - geth 내부, 웹사이트나 데이터 베이스에 저장됨
  - 제 3자를 신뢰해야 할 수도 있음
- 오프라인 지갑
  - 인터넷에 연결되어있지 않음
  - USB 드라이브, 종이, 텍스트 파일 등에 저장됨
  - 콜드 지갑이라고도 불리움

## hooked-web3-provider 및 ethereumjs-tx 라이브러리

- 앞서 web3.js 라이브러리 sendTransaction() 메소드의 모든 예제는 이더리움 노드에 존재하는 from 주소를 사용했다.
- 따라서 이더리움 노드가 브로드 캐스팅 전에 트랜잭션에 서명할 수 있었다.
- 하지만 개인키가 다른곳에 저장되었다면 geth는 개인키를 찾을수 없으므로, 이 경우는 트랜잭션 브로드캐스팅을 위해 web3.eth.sendRawTransaction을 사용해야한다.
- 그러나 이는 데이터 부분 생성, 원시 트랜잭션 생성, 트랜잭션 서명이 필요하므로 어렵다.

### hooked-web3-provider 라이브러리

- HTTP를 사용해 geth와 통신하는 커스텀 공급자를 제공
- 해당 공급자는 우리의 키를 사용해 컨트랙트인스턴스의 sendTransaction에 호출할수 있도록 해줌.
- 따라서 더이상 트랜잭션의 데이터 부분을 만들 필요가 없음

### ethereumjs-tx

- ethereumjs는 이더리움과 연관된 라이브러리 모음.
- ethereumjs-tx는 트랜잭션과 연관된 다양한 API를 제공하는 라이브러리중 하나.
- ex) 원시 트랜잭션 생성, 서명, 서명 검증

## HD 지갑(hierarchical deterministic wallet)

계층 결정적 지갑, 즉 HD 지갑은 시드라고 불리는 단일 시작 지점으로 부터 주소와 키를 얻어낼 수 있는 시스템이다. 이름의 의미는 다음과 같다.

- 결정적: 같은 시드를 사용하면 같은 주소와 키를 생성할 수 있음
- 계층적 : 주소와 키가 같은 순서로 생성됨

다양한 형식의 HD 지갑이 있으며, 시드의 형식과 주소 및 키를 생성하는 알고리즘간에는 차이가 있다.(IBK32, Armory, Coinkite, Coinb.in 등)

### 왜 사용자가 다수의 계좌를 사용해야할까?

이유는 사용자가 자신의 재산을 숨기기 위함이다.
계좌의 잔액은 블록체인 내에 공개되어있므로, 사용자 A가 이더를 받기 위해 사용자 B에게 주소를 아려준 경우 사용자는 B에 해당하는 계좌에 얼마나 많은 이더가 있는지 확인이 가능하다.

## LightWallet

LightWallet은 BIP32, BIP39, BIP44를 구현한 HD 지갑이다.
또한 트랜잭션은 생성하고 서명한 후, 이를 사용해 생성된 주소 키를 이용함으로써 데이터를 암호화/복호화할 수 있는 API를 제공한다.

LightWallet의 API는 다음과 같은 4개의 네임스페이스로 이루어진다.

- keystore : 시드와 암호화된 키를 저장하는 객체
- signing : 트랜잭션 서명
- encryption : 비동기식 암호화
- txutils : 트랜잭션 생성을 위한 api

### HD 유도 경로

HD 유도 경로는 다수의 암호화폐, 다수의 블록체인, 다수의 계좌 등을 처리하기 쉽게 만들어 주는 문자열이다.
이는 원하는 만큼 많은 매개변수를 가질수 있으며 매개변수에 대한 다른값을 사용해서 서로 다른 그룹 주소와 연관된 키를 생성할 수 있다.

기본적으로 LightWallet은 m/0'/0'/0' 유도경로를 사용한다. 여기서 /n'은 매개 변수며 n은 매개변수의 값이다.


### 예제코드 백엔드 실행 명령어

```
geth --dev --rpc --rpccorsdomain "*" --rpcaddr "0.0.0.0" --rpcport "8545" --mine --unlock=0
```