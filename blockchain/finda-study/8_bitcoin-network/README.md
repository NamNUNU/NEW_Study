# The Bitcoin Net work

# peer to peer network architecture

비트 코인은 peer to peer 구조를 따른다. peer to peer에는 다음과 같은 특징이 있다
1. 모두 동등하다
2. "특별한" 노드가 없다
3. 모든 노드가 동일한 네트워크 서비스를 제공받는다

따라서 동일한 레벨의 토폴로지 네트워크를 형성한다는 것이다.
네트워크 안에는 서버도 없고 중심화된 서비스도 없으며, 계층도 없다.
P2P 네트워크는 탈중앙화 되어있으며 복구가능하고 peer들에게 열러있다.
탈중앙화의 제어는 p2p 네트워크의 의견 일치를 만들어낼 유일한 핵심 개념이다
우리는 비트코인 네트워크를 구성하는 여러가지 프로토콜에 대해서 알아볼것이다.

# 노드 타입과 역할

비록 비트코인  P2P 네트워크가 동등하다고 하나, 자신의 역할에 따라 다른 기능을 서포트한다.
예를 들면 비트코인 노드는 지갑, 마이닝, 라우팅, 비트코인 데이터베이스 등을 모아놓고 있다.

모든 노드는 검증하고 트랜지션을 확장하고, 발견하며, peer와의 연결을 유지한다.
그림.8-1 에 보이는 라우팅 기능은 Network Routing Node, 또는 N으로 표현된다.

풀노드는 블록체인 사본의 업데이트를 하고 자체적으로 외부의 참조 없이 트랜잭션을 검증한다.
SPV 노드는 simplified payment Verification(SPV)라는 메소드를 가지고 블록체인의 서브셋을 검사한다.

그림.8-1 에 보이는 풀노드 블록체인 데이터베이스 기능은 Full Blockchain 또는 B로 표현된다.

마이닝 노드는 작업의 증명 후 새로운 노드를 갱신한다.
마이닝 기능은 풀 노드 안에 있으며 Miner 또는 M으로 표현된다.

유저 지갑은 풀노드의 일부분이다.
지갑은 Wallet 또는 W로 표현된다.

# 비트코인 네트워크의 확장
P2P 네트워크 중의 소수만이 마이닝 프로세스를 완료하고, 트랜잭션을 검증하며, 새로운 블록을 생성하는 마이닝 노드이다.

- Reference Client(지갑, 마이너, 블록체인 데이터베이스, 네트워크 라우팅 노드)
- Full Block Chain Node(블록체인 데이터베이스, 네트워크 라우딩 노드)
- Solo Miner(블록체인 데이터베이스 사본, P2P 네트워크 라우팅 노드, 마이너)
- Lightweight(SPV) Wallet(지갑, 네트워크 라우팅 노드)
- Pool Protocol server(pool server, Stratum server)
- Mining Nodes(마이너, pool server, Stratum server)
- Lighiweight(SPV) Stratum wallet(지갑, Stratum server)

# 비트코인 중개 네트워크

마이너의 작업 증명은 시간에 상당히 민감하므로 승자 블록이 살아남고 이익을 얻기 위해서는 네트워크가 중요하다.
이때문에 블록과 마이너 사이의 대기시간을 최소화 하는게 중요한데, 이와 같은 맥락에서 비트코인 중개 네트워크가
2015년 비트코인 코어 개발자로부터 탄생했다.
네트워크에는 몇개의 특별한 노드들이 AWS위에서 주요 마이너와 마이닝 풀을 연결해 주고 있다.

비트코인 중개 네트워크는 동일한 개발자가 개발한Fast internet bitcoin relay engine(FIBRE)라는 것으로 2016년 교체되었다.
FIBRE는 네트워크에서 데이터 전송을 최적화하기 위해 개발되었다.

다른 중개 네트워크는 Falcon이 있다. 
Falcon은 'store-and-forward'대신에 'cut-through-routing' 를 사용한다.

비트코인 중개 네트워크는 비트코인 P2P 네트워크를 대체하지 않는다. 
대신 노드와 특별한 요구에 대한 추가적 연결을 제공한다.
예를 들어 고속도로가 국도를 대체하지 않는것 처럼 말이다.

# 네트워크 발견

새로운 노드가 만들어졌을때 반드시 네트워크상의 다른 노드를 찾아야한다.
지리학적 위치는 상관이 없다. 비트코인 네트워크 토폴로지는 지리적으로 정의되어있지 않다.
결과적으로 비트코인 노드의 선택은 랜덤이다.
알려진 peer에 연결하는 것은 8333 포트나 다른 노드의 TCP 연결로 이루어진다.
연결이 시작될때 노드는 버전 메세지를 보내는것으로 "핸드쉐이크"를 시작한다.

nVersion : 비트코인 P2P 프로토콜 버전(ex)70002 )
nLocalServices: 노드로 부터 지원받는 로컬 서비스의 리스트, 현재는 그냥 NODE_NETWORK
nTime: 현재 시각
addrYou: 원격 노드에서 현재 노드를 보는 IP 어드레스
addrME: 로컬 노드의 IP 어드레스
subver: 현재 노드에서 돌아가는 소프트웨어 타입의 서브 버전
BestHeight: 이 노드 블록체인의 블록 높이

먼저 클라이언트는 이전에 연결했던 Peer를 캐시에서 가져와 사용할 수 있다.
다음으로 DNS Seed를 사용할 수 있다. 클라이언트가 처음으로 구동되었을 때는, 이전에 사용한 Peer가 없을 것이다. 이런 경우에 일반적으로 DNS Seeding이라고 불리우는 방법을 사용한다. 즉, 비트코인 클라이언트는 DNS Seed 라고 불리우는 하나 이상의 DNS 호스트명을 쿼리하여 Peer들의 IP 정보를 얻을 수 있다. 이러한 DNS 쿼리는 현재 사용중인 Full 노드들의 IP 주소들을 리턴하게 된다. 비트코인 클라이언트는 널리 알려진 DNS Seed 들을 하드코드하여 사용하곤 하는데, 이러한 DNS Seed들은 비트코인 커뮤너티에 의해 관리된다. DNS Seed에는 네트크워 스캔을 통해 자동으로 갱신되는 Dynamic DNS Seed와 수작업으로 IP를 갱신하는 Static DNS Seed가 있다.

8-4에서 initialize 핸드쉐이킹 과정

핸드쉐이킹 이후, 노드는 이웃 노드에게 IP 어드레스를 getAddr 메소드로 요청한다
이웃 노드는 이에 따라 어드레스의 리스트를 반환한다.

노드는 비트코인 네트워크에 경로를 생성하기 위해 반드시 소수의 서로다른 peer 들과 연결되어야한다.
이 연결이 해제되었을때 노드는 끊임없이 새 노드에 대한 연결을 수행한다.
부트스트래핑 이후 노드는 최근 peer와의 성공적인 연결에 대한 정보를 기억한다.
왜냐하면 일반적인 노드에 대한 연결을 빠르게 수행하기 위해서 이다.
만약 일반적인 peer에대한 연결이 없다면 노드는 시드 노드의 부트스트래핑을 다시 사용할수 있다.

노드가 비트코인 클라이언트에서 돌아가는 동안, getpeerinfo 명령어로 연결 목록을 받아올수 있다.
p.179 참조

자동연결 대신에 수동으로 연결이 가능하며 명령어는 -connect<IPAddress>이다.

연결에 트래픽이 없다면 노드는 주기적으로 메세지를 보내 연결을 유지한다.
또한 90분 이상 커뮤니케이션이 없으면 자동으로 연결을 끊고 다른 노드를 찾는다.
따라서 중앙 제어 없이도 유동적으로 네트워크 관리가 가능해진다.

# Full node

풀 노드는 모든 트랜잭션을 가진 풀 블록체인을 유지한다. 
풀노드는 "풀 블록체인 노드"라고도 불릴 수 있다.
제일 처음에는 모든 녿가 풀 노드였고 비트 코인 코어 클라이언트는 풀 블록체인 노드였다.
그러나 2년전부터 경량화된 클라이언트를 위해 더이상 풀 블록 체인을 유지하지 않아도 되는 폼이 등장했다.

풀 블록체인은 독립적이며, genesis block으로 시작하며, 가장 최근 블록을 업데이트 한다.
또한 자체적이며 독립적으로 트랜잭션을 검증한다. 
그리고 이는 네트워크에서 전송되는 새로운 블록에 대한 업데이트에 의존한다.

다만 모든 트랜잭션과 블록체인을 다운 받는 것이므로 시간과 용량이 많이 필요하다.
여러가지 풀 노드 버전이 있지만 가장 대표적인것은 사토시 클라이언트라고 알려진 클라이언트 비트코인 코어이다.
비트코인 네트워크의 75퍼센트 이상의 노드가 다양한 버전의 비트코인 코어이다.

# 인벤토리 교환

블록체인 싱크의 첫번째는 version을 가져오는 것이다. 
왜냐하면 여기에 현재 블록의 높이를 뜻하는 BestHeight를 가지고 있기 때문이다,
노드는 version을 보고 peer의 블록이 어느정도 있는지 확인한다.
peer 블록은 getblocks 메세지로 top block의 hash를 교환한다.
하나의 블록에는 hash 값이 없을것이며 다른 한 곳에는 오래된 블록중에 hash를 포함하고 있을것이다.
이를 통해 어떤 블록이 더 긴지 알수 있다.

큰쪽에서는 작은쪽으로 다음 500개 블록에대한 hash를 담은 inv 메세지를 보내고
max_block_in_transit_per_peer 값을 측정하여 block을 전송하게 된다.
이 프로세스의 시작은 getblocks와 함께 시작하고 inv 메세지를 받으면 없는 블록에 대한 다운로드가 진행된다.

# SPV 노드

모든 노드가 풀 노드 블록체인은 아니다.
많은 비트 코인 클라이언트가 스마트폰과 같은 기기에서도 동작하도록 디자인 되었다.
이러한 디바이스에서 SPV 경량 노드가 사용된다. 특히나 이는 코인 지갑에 많이 사용된다.

SPV 노드는 블록의 헤더만 받고 트랜잭션은 하나도 받지 않는다.
결과적으로 이는 1000배나 작은 풀 블록체인이 된다.
따라서 SPV의 검증을 위해 다른 peer에 의존하게 된다.

예를 들자면 풀노드는 지도를 가지고 낯선 도시로 떠난 여행객이라면,
SPV 노드는 랜덤으로 물어서 낯선 도시를 탐험하는 여행객이라고 할수 있다.
결국, 두 여행객 모두 해당 장소가 있는지 검증할수 있지만, 방법에서 차이가 나는 것이다.
결국 지도 없이 다니는 여행객이 할수 있는 최선의 방법은 사람들에게 충분히 물어보는 것이다.

SPV는 머클 경로 요청으로 블록체인의 작업의 증명을 검증한다. 
그러나 트랜잭션은 실제로 SPV에 존재하지 않는다.
따라서, 이는 이중 지불 문제를 발생시킬수 있으며, 이를 해결하기 위해서는
랜덤으로 연결을 하고, 신뢰할만한 노드에 의지해야한다. 
랜덤 연결은 fake 노드에 연결될 만할 확률을 줄인다.

블록체인의 헤더를 얻기 위해 getblock 대신 getheaders 메세지를 보낸다
응답하는 peer는 2000개의 블록을 headers 메세지 하나로 보내게된다.

# Bloom filter

블룸 필터는 정확한 묘사 없이 패턴을 통해 검색하는 필터이다.
이는 개인정보를 방시하면서 효육적으로 검색하는 패턴을 제공한다.
또한, 어드레스를 노출하지않고 peer에게 특정한 패턴이 트랜지션과 매치되는가를 물어본다.

예를 들어, 블룸 필터는 이런식으로 물어볼것이다
"자신 주변에 R-C-H로 끝나는 주소가 있나요?"
따라서 적은 정보만으로 목적지를 찾을수 있다.

# Bloom filter 의 동작 방식

블룸 필터는 N binary ditgits로 구성된 다양한 사이즈의 배열과 M hash 함수로 구성된다.
해쉬 함수는 언제나 1에서 N을 출력하며, 동일한 해쉬 함수를 사용하므로 특정 입력값에 동일한 출력값을 낸다

8-8번 그림을 통해 우리는 아주 작은 입력값과 3개의 해쉬함수로 어떻게 블룸 필터가 동작하는지 알아본다.

처음 블룸필터는 배열 전체를 0으로 초기화 한다.
패턴을 블룸필터에 더하기 위해서 패턴을 각각의 해쉬함수에 의해 해쉬되어야한다.
1번 해쉬 함수부터 차례로 패턴을 해싱하고, 결과값으로 나온 인덱스의 값을 1로 변환한다.
모든 작업이 완료되면 "레코드"되었다고 표현한다.

두번째 패턴도 이와같은 프로세스로 간단하게 더해진다.
블룸 필터는 더 많은 패턴으로 채워지고,해쉬 함수의 결과값은 1로 채워질 것이다.

정확도는 패턴의 개수와 배열의 사이즈, 해쉬 함수의 개수에 의존적이다.
큰 비트의 배열과 많은 해쉬 함수는 많은 패턴을 정확하게 레코드할 수 있다.

따라서 패턴이 X나 Y를 포함하고 있는지 해쉬함수와 결과값을 대조하며 검증할수 있는 것이다.
